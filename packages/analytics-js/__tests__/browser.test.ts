/* eslint-disable global-require */
import { loadingSnippet } from './nativeSdkLoader';

const pathToSdk = '../dist/cdn/legacy/iife/rsa.js';

function wait(time: number) {
  return new Promise(resolve => {
    setTimeout(resolve, time);
  });
}

function dispatchPageHideEvent() {
  document.dispatchEvent(new Event('pagehide'));
}

describe('Test suite for the SDK', () => {
  const fetchMock = jest.fn(() =>
    Promise.resolve({
      ok: true,
      json: () =>
        Promise.resolve({
          source: {
            config: {},
            id: 'id',
            destinations: [],
          },
        }),
      text: () =>
        Promise.resolve(
          JSON.stringify({
            source: {
              config: {},
              id: 'id',
              destinations: [],
            },
          }),
        ),
    }),
  );

  const userId = 'jest-user-id';
  const userTraits = {
    'jest-user-trait-key-1': 'jest-user-trait-value-1',
    'jest-user-trait-key-2': 'jest-user-trait-value-2',
  };

  const groupUserId = 'jest-group-id';
  const groupTraits = {
    'jest-group-trait-key-1': 'jest-group-trait-value-1',
    'jest-group-trait-key-2': 'jest-group-trait-value-2',
  };

  const originalFetch = window.fetch;

  afterEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
    jest.restoreAllMocks();

    window.rudderanalytics = undefined;

    window.fetch = originalFetch;
  });

  describe('preload buffer', () => {
    it('should process the buffered API calls when SDK script is loaded', async () => {
      // Mocking the fetch function
      window.fetch = fetchMock;
  
      loadingSnippet();
      rudderanalytics.page();
  
      require(pathToSdk);
      await wait(500);
  
      expect(window.rudderanalytics.push).not.toBe(Array.prototype.push);
  
      dispatchPageHideEvent();
  
      // one source config endpoint call and one implicit page call
      // Refer to above 'beforeEach'
      expect(fetchMock).toHaveBeenCalledTimes(2);
    });
  });

  describe('SDK APIs', () => {
    beforeEach(async () => {
      // Mocking the fetch function
      window.fetch = fetchMock as unknown as typeof window.fetch;

      loadingSnippet();

      require(pathToSdk);
      await wait(500);
    });

    it('should make network requests when event APIs are invoked', () => {
      rudderanalytics.page();
      rudderanalytics.track('test-event');
      rudderanalytics.identify('jest-user');
      rudderanalytics.group('jest-group');
      rudderanalytics.alias('new-jest-user', 'jest-user');

      dispatchPageHideEvent();

      // one source config endpoint call and individual event requests
      expect(fetchMock).toHaveBeenCalledTimes(6);
    });

    describe('getAnonymousId', () => {
      it('should return a new UUID when no prior persisted data is present', () => {
        const anonId = rudderanalytics.getAnonymousId();

        const uuidRegEx = /^[\da-f]{8}-[\da-f]{4}-4[\da-f]{3}-[\da-f]{4}-[\da-f]{12}$/i;
        expect(anonId).toMatch(uuidRegEx);
      });

      it('should persist the anonymous ID generated by the SDK', () => {
        const anonIdRes1 = rudderanalytics.getAnonymousId();

        // SDK remembers the previously generated anonymous ID and returns the same value
        const anonIdRes2 = rudderanalytics.getAnonymousId();

        expect(anonIdRes1).toEqual(anonIdRes2);
      });
    });

    describe('reset', () => {
      it('should clear all the persisted data except for anonymous ID when the flag is not set', () => {
        // Make identify and group API calls to let the SDK persist
        // user (ID and traits) and group data (ID and traits)
        rudderanalytics.identify(userId, userTraits);
        rudderanalytics.group(groupUserId, groupTraits);

        const anonId = 'jest-anon-ID';
        rudderanalytics.setAnonymousId(anonId);

        // SDK clears all the persisted data except for anonymous ID
        rudderanalytics.reset();

        // SDK remembers the previously generated anonymous ID and returns the same value
        const anonIdRes = rudderanalytics.getAnonymousId();

        expect(anonId).toEqual(anonIdRes);
        expect(rudderanalytics.getUserId()).toEqual('');
        expect(rudderanalytics.getUserTraits()).toEqual({});
        expect(rudderanalytics.getGroupId()).toEqual('');
        expect(rudderanalytics.getGroupTraits()).toEqual({});
      });

      it('should clear all the persisted data include anonymous ID when the flag is set', () => {
        // Make identify and group API calls to let the SDK persist
        // user (ID and traits) and group data (ID and traits)
        rudderanalytics.identify(userId, userTraits);
        rudderanalytics.group(groupUserId, groupTraits);

        const anonId = 'jest-anon-ID';
        rudderanalytics.setAnonymousId(anonId);

        // SDK clears all the persisted data
        rudderanalytics.reset(true);

        // SDK remembers the previously generated anonymous ID and returns the same value
        const anonIdRes = rudderanalytics.getAnonymousId();

        expect(anonId).not.toEqual(anonIdRes);
        expect(rudderanalytics.getUserId()).toEqual('');
        expect(rudderanalytics.getUserTraits()).toEqual({});
        expect(rudderanalytics.getGroupId()).toEqual('');
        expect(rudderanalytics.getGroupTraits()).toEqual({});
      });
    });
  });
});
